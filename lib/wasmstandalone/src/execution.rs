use cretonne::Context;
use cretonne::settings;
use cretonne::isa;
use cretonne::ir::{Ebb, FuncRef, JumpTable};
use cretonne::binemit::{RelocSink, Reloc, CodeOffset};
use wasm2cretonne::{TranslationResult, FunctionTranslation, ImportMappings};
use std::mem::transmute;
use region::Protection;
use region::protect;
use std::collections::HashMap;
use std::ptr::write_unaligned;

type RelocRef = u16;

struct StandaloneRelocSink {
    ebbs: HashMap<RelocRef, (Ebb, CodeOffset)>,
    funcs: HashMap<RelocRef, (FuncRef, CodeOffset)>,
    jts: HashMap<RelocRef, (JumpTable, CodeOffset)>,
}

struct FunctionMetaData {
    relocs: StandaloneRelocSink,
    imports: ImportMappings,
}

impl RelocSink for StandaloneRelocSink {
    fn reloc_ebb(&mut self, offset: CodeOffset, reloc: Reloc, ebb: Ebb) {
        self.ebbs.insert(reloc.0, (ebb, offset));
    }
    fn reloc_func(&mut self, offset: CodeOffset, reloc: Reloc, func: FuncRef) {
        self.funcs.insert(reloc.0, (func, offset));
    }
    fn reloc_jt(&mut self, offset: CodeOffset, reloc: Reloc, jt: JumpTable) {
        self.jts.insert(reloc.0, (jt, offset));
    }
}

impl StandaloneRelocSink {
    fn new() -> StandaloneRelocSink {
        StandaloneRelocSink {
            ebbs: HashMap::new(),
            funcs: HashMap::new(),
            jts: HashMap::new(),
        }
    }
}

/// Executes a module that has been translated with the `StandaloneRuntime` runtime implementation.
/// Recognized ISAs are `"intel"`, `"riscv"`, `"arm32"`, `"arm64"`.
pub fn execute_module(trans_result: &TranslationResult, isa: &str) -> Result<(), String> {
    let shared_builder = settings::builder();
    let shared_flags = settings::Flags::new(&shared_builder);
    let isa = match isa::lookup(isa) {
        None => {
            panic!() // The Intel target ISA is not available.
        }
        Some(isa_builder) => isa_builder.finish(shared_flags),
    };
    let mut functions_metatada = Vec::new();
    let mut functions_code = Vec::new();
    for function in trans_result.functions.iter() {
        let mut context = Context::new();
        let (il, imports) = match function {
            &FunctionTranslation::Import() => {
                return Err(String::from("start function should not be an import"))
            }
            &FunctionTranslation::Code {
                ref il,
                ref imports,
                ..
            } => (il.clone(), imports.clone()),
        };
        context.func = il;
        let code_size = context.compile(&*isa).unwrap() as usize;
        if code_size == 0 {
            return Err(String::from("no code generated by Cretonne"));
        }
        let mut code_buf: Vec<u8> = Vec::with_capacity(code_size);
        code_buf.resize(code_size, 0);
        let mut relocsink = StandaloneRelocSink::new();
        context.emit_to_memory(code_buf.as_mut_ptr(), &mut relocsink, &*isa);
        functions_metatada.push(FunctionMetaData {
                                    relocs: relocsink,
                                    imports: imports,
                                });
        functions_code.push(code_buf);
    }
    // After having emmitted the code to memory, we deal with relocations
    for (func_index, function_in_memory) in functions_metatada.iter().enumerate() {
        for (_, &(func_ref, offset)) in function_in_memory.relocs.funcs.iter() {
            let reloc_func_index = function_in_memory.imports.functions[&func_ref];
            let reloc_address = functions_code[reloc_func_index].as_ptr();
            unsafe {
                write_unaligned(functions_code[func_index]
                                    .as_mut_ptr()
                                    .offset(offset as isize) as
                                *mut u32,
                                reloc_address as u32);
            }
        }
    }
    match trans_result.start_index {
        None => Err(String::from("No start function defined, aborting execution")),
        Some(index) => execute(&mut functions_code[index]),
    }
}

fn execute(code_buf: &mut Vec<u8>) -> Result<(), String> {
    unsafe {
        match protect(code_buf.as_ptr(),
                      code_buf.len(),
                      Protection::ReadWriteExecute) {
            Ok(()) => (),
            Err(err) => {
                return Err(format!("failed to give executable permission to code: {}",
                                   err.description()))
            }
        };
        let start_func = transmute::<_, fn()>(code_buf.as_ptr());
        start_func();
        Ok(())
    }
}
